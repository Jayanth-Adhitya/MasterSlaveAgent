## ADDED Requirements

### Requirement: Asynchronous Message Queue Processing
The system SHALL process user messages asynchronously via Redis Streams with consumer groups.

#### Scenario: Message enqueued for processing
- **WHEN** a user sends a message via the API
- **THEN** the message is immediately acknowledged (202 Accepted)
- **AND** the message is added to the appropriate Redis Stream

#### Scenario: Worker consumes message from stream
- **WHEN** a message is available in a Redis Stream
- **THEN** a worker picks up the message via consumer group
- **AND** the message is marked as pending until processed

#### Scenario: Message processing completes
- **WHEN** the worker finishes processing a message
- **THEN** the message is acknowledged in the consumer group
- **AND** the result is published for the user

### Requirement: LLM Response Generation
The system SHALL generate responses using LangChain with Gemini (ChatGoogleGenerativeAI) model via SlaveAgent.

#### Scenario: LLM generates contextual response
- **WHEN** a user message is processed by the worker
- **THEN** the message is routed to the tenant's SlaveAgent
- **AND** SlaveAgent invokes LangChain with tenant context and conversation history
- **AND** returns the LLM-generated response with optional actions

#### Scenario: LLM error handled gracefully
- **WHEN** the LLM service fails (timeout, rate limit, API error)
- **THEN** the system returns an error message to the user
- **AND** logs the error for debugging

### Requirement: Per-User Conversation Memory
The system SHALL maintain conversation history per user session using in-memory storage keyed by `{tenant_id}:{user_id}:{session_id}`.

#### Scenario: Conversation context preserved
- **WHEN** a user sends multiple messages in the same session
- **THEN** the LLM receives previous conversation history
- **AND** responses are contextually aware of prior exchanges

#### Scenario: Memory isolated per user
- **WHEN** two users in the same tenant have separate sessions
- **THEN** each user's memory is independent
- **AND** User A's conversation does not affect User B's responses

#### Scenario: New session starts fresh
- **WHEN** a user starts a new session (new session_id)
- **THEN** the conversation memory starts empty
- **AND** previous sessions are not loaded into context

### Requirement: Message Persistence
The system SHALL persist all messages (user and assistant) to PostgreSQL for audit and recovery.

#### Scenario: User message stored
- **WHEN** a user sends a message
- **THEN** the message is saved to the database with role='user'
- **AND** includes tenant_id, user_id, session_id, and timestamp

#### Scenario: Assistant response stored
- **WHEN** the LLM generates a response
- **THEN** the response is saved to the database with role='assistant'
- **AND** linked to the same session_id

### Requirement: Real-Time Response Delivery
The system SHALL deliver LLM responses to users in real-time via WebSocket connection.

#### Scenario: User receives response via WebSocket
- **WHEN** the worker completes processing a message
- **THEN** the response is pushed to the user's WebSocket connection
- **AND** the user sees the response without page refresh

#### Scenario: WebSocket connection authenticated
- **WHEN** a user establishes a WebSocket connection
- **THEN** the connection requires a valid JWT token
- **AND** unauthorized connections are rejected

### Requirement: Cross-User Notification Delivery
The system SHALL persist notifications generated by LLM actions for target users to view.

#### Scenario: Notification stored for target user
- **WHEN** SlaveAgent executes a notify_user action
- **THEN** notification is inserted into database with to_user_id
- **AND** includes tenant_id, from_user_id, message, and timestamp

#### Scenario: User retrieves their notifications
- **WHEN** a user queries their notifications
- **THEN** only notifications where to_user_id matches their user_id are returned
- **AND** notifications are filtered by tenant_id

#### Scenario: Notification marked as read
- **WHEN** a user marks a notification as read
- **THEN** the notification's read status is updated in database
- **AND** read timestamp is recorded
